---
title: "Using lintr"
author: "Alexander Rosenstock"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using lintr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

This vignette describes how to set up and configure `lintr` for use with projects or packages.

## Running `lintr` on a project

Checking a R project for lints can be done with three different functions:

* Lint a single file using `lint()`:

```r
lint(filename = "R/bad.R")
```

* Lint a directory using `lint_dir()`:

```r
lint_dir(path = "R")
```

This will apply `lint()` to all R source files matching the `pattern` argument.
By default, this means all `.R` files as well as `knitr` formats (e.g. `.Rmd`, `.Rnw`).

`lint_dir` is vectorized over `path`, so multiple directories can be linted at the same time.

* Lint all relevant directories of an R package using `lint_package()`:

```r
lint_package(path = ".")
```

This will apply `lint_dir()` to all subdirectories usually containing R code in packages:

 - `R` containing the package implementation.
 - `tests` containing test code.
 - `inst` containing sample code or vignettes that will be installed along with the package.
 - `vignettes` containing package vignettes.
 - `data-raw` containing code to produce `data` files.

For more information about the assumed package structure, see
[R Packages](https://r-pkgs.org/package-structure-state.html).

## Configuring linters

### The `.lintr` file

For R projects or R packages the most convenient method of configuration is creating a `.lintr` file in the project
root. This file is in debian control format (`?read.dcf`) and each key is evaluated as R code by `lintr` when reading
the settings.

The settings file is searched for in the following order:

 1. If `options(lintr.linter_file)` is an absolute path, this file will be used.
    The default for this option is `".lintr"`.
 2. If there is a file named like `lintr.linter_file` in the currently searched directory, this file will be used.
 3. Parent directories of the currently searched directory are searched for the linter file. If one is found, this file
    will be used.
 4. If a linter file exists in the users `HOME` directory, this file is used.

If none of the steps yield an existing linter file, no configuration is loaded from the file.

### Using `options()`

Settings from the `.lintr` file can be overridden using `options`. An option `option_name` is read from
`lintr.option_name`. If that is non-`NULL`, it will take precedence over settings from the `.lintr` file.

### Using arguments to `lint()`

The settings can also be passed as arguments to linting functions directly.
In case of `exclusions`, these will be combined with the globally parsed settings. Other settings will be overridden.

If only the specified settings should be changed, and the remaining settings should be taken directly from the defaults,
the argument `parse_settings = FALSE` can be added to the function calls. This will suppress reading of the `.lintr`
configuration. This is particularly useful for tests which should not exclude example files containing lints while the
package-level `.lintr` excludes those files because the lints are intentional.

### Defaults

The default settings of `lintr` are intended to conform to the [tidyverse style guide](https://style.tidyverse.org/).
However, the behavior can be customized using different methods.

Apart from `lintr.linter_file`, which defaults to `".lintr"`, there are the following settings:

```{r, echo = FALSE}
default_settings <- lintr::default_settings
default_settings$linters <- "`lintr::default_linters`"
default_settings$comment_token <- "(lintr-bot comment token for automatic GitHub comments)"
default_settings$exclusions <- "(empty)"

make_string <- function(x) {
  if (inherits(x, "regex")) {
    paste0("regex: `", x, "`")
  } else {
    as.character(x)
  }
}

defaults_table <- data.frame(
  default = vapply(default_settings, make_string, character(1L)),
  stringsAsFactors = FALSE
)

knitr::kable(defaults_table)
```

#### Customizing active linters

If one wants to only customize some linters, one can use the helper function `with_defaults()`, which will keep all
untouched linters with the default settings. Disable a linter by passing `NULL`. For example, to set the line length
limit to 120 characters and globally disable the `no_tab_linter`, you can put this into your `.lintr`:

```r
linters: with_defaults(
    line_length_linter = line_length_linter(120L),
    no_tab_linter = NULL
  )
```

By default, the following linters are enabled. Where applicable, the default settings are also shown.

```{r, echo = FALSE}
default_linters <- lintr::default_linters
linters_with_args <- list(
  cyclocomp_linter = "complexity_limit",
  line_length_linter = "length",
  object_length_linter = "length",
  closed_curly_linter = "allow_single_line",
  object_name_linter = "styles",
  open_curly_linter = "allow_single_line"
)

make_setting_string <- function(linter_name) {
  args <- linters_with_args[[linter_name]]
  if (is.null(args)) return("")

  arglist <- vapply(args, function(arg) {
    env <- environment(default_linters[[linter_name]])
    if (linter_name == "object_length_linter") {
      # object_length_linter creates a inner implementation named `fun`.
      # all other linters keep their configuration in the same environment as the linter function.
      env <- environment(env[["fun"]])
    }
    deparse(env[[arg]])
  }, character(1L))

  paste0(args, " = ", arglist, collapse = ", ")
}

defaults_table <- data.frame(
  row.names = names(default_linters),
  settings = vapply(names(default_linters), make_setting_string, character(1L)),
  stringsAsFactors = FALSE
)

knitr::kable(defaults_table)
```

## Exclusions

Sometimes, linters should not be globally disabled. Instead, one might want to exclude some code from linting altogether
or selectively disable some linters on some part of the code.

### Excluding lines of code

Within source files, special comments can be used to exclude single lines of code from linting.
All lints produced on the marked line are excluded from the results.

By default, this special comment is `# nolint`:

**file.R**
```r
X = 42L # -------------- this comment overflows the default 80 chars line length.
```

`> lint("file.R")`
```{r, echo = FALSE}
lintr::lint("X = 42L # -------------- this comment overflows the default 80 chars line length.\n",
            parse_settings = FALSE)
```

**file2.R**
```r
X = 42L # nolint ------ this comment overflows the default 80 chars line length.
```

`> lint("file2.R")`
```{r, echo = FALSE}
lintr::lint("X = 42L # nolint ------ this comment overflows the default 80 chars line length.\n",
            parse_settings = FALSE)
```
Observe how all lints were suppressed and no output is shown.
Sometimes, only a specific linter needs to be excluded. In this case, the *name* of the linter can be appended to the
`# nolint` comment preceded by a colon and terminated by a dot.

**file3.R**
```r
X = 42L # nolint: object_name_linter. this comment overflows the default 80 chars line length.
```

`> lint("file3.R")`
```{r, echo = FALSE}
lintr::lint("X = 42L # nolint: object_name_linter. this comment overflows the default 80 chars line length.\n",
            parse_settings = FALSE)
```
Observe how only the `object_name_linter` was suppressed. This is preferable to blanket `# nolint` statements because
they may accidentally silence a linter that was not intentionally suppressed.

Multiple linters can be specified by listing them with a comma as a separator:

**file4.R**
```r
X = 42L # nolint: object_name_linter, line_length_linter. this comment overflows the default 80 chars line length.
```

`> lint("file4.R")`
```{r, echo = FALSE}
lintr::lint(
  paste(
    "X = 42L",
    "# nolint: object_name_linter, line_length_linter. this comment overflows the default 80 chars line length.\n"
  ),
  parse_settings = FALSE
)
```

#### Excluding multiple lines of codes

If any or all linters should be disabled for a contiguous block of code, the `exclude_start` and `exclude_end` patterns
can be used. They default to `# nolint start` and `# nolint end` respectively.

The `# nolint start` accepts the same syntax as `# nolint` to disable specific linters in the following lines until a
`# nolint end` is encountered.

```r
# x <- 42L
# print(x)
```

```{r, echo = FALSE}
lintr::lint("# x <- 42L\n# print(x)\n", parse_settings = FALSE)
```

```r
# nolint start: commented_code_linter.
# x <- 42L
# print(x)
# nolint end
```

```{r, echo = FALSE}
lintr::lint("# nolint start: commented_code_linter.\n# x <- 42L\n# print(x)\n# nolint end\n",
            parse_settings = FALSE)
```
(No lints)

#### Excluding lines via the config file

Individual lines can also be excluded via the config file.
To exclude all lints for line 1 of file `R/bad.R` and line_length_linter for lines 4 to 6 of the same file, one can set

```r
exclude: list(
    "R/bad.R" = list(
      1, # global exclusions are unnamed
      line_length_linter = 4:6
    )
  )
```

All paths are seen as relative to the location of the `.lintr` file.

### Excluding files

The linter configuration can also be used to exclude a file entirely, or a linter for a file entirely.
Use the sentinel line number `Inf` to mark all lines as excluded within a file. If a file is only given as a character
vector, full exclusion is implied.

```r
exclude: list(
    # excluded from all lints:
    "R/excluded1.R",
    "R/excluded2.R" = Inf,
    "R/excluded3.R" = list(Inf),
    # excluded from line_length_linter:
    "R/no-line-length.R" = list(
      line_length_linter = Inf
    )
  )
```

### Excluding directories

To exclude an entire directory from linting, specify it as a file name. For example, to exclude the `renv` library from
linting in a R project using `renv`, set

```r
exclude: list(
    "renv"
  )
```

This is particularly useful for projects which somehow include external code in subdirectories
